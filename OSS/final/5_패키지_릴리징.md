# Release Numbering
## Release
- 일부 오래된 버그 수정
- 새로운 버그, 특징, 설정 옵션 추가
- 비호환적인 변화가 알려짐(데이터 포맷 문제)
- 사용 목적
    + 릴리즈 시리즈 내에서 릴리즈의 순서간 커뮤니케이션을 모호하지 않게 하기 위해
    + 각 릴리즈의 변화의 정도를 압축해서 표현하기 위함
    + **넘버링, 텍스트는 일관되게 하기**

## Release Number Components
- 릴리즈 번호: Dot에 의해 분리된 숫자 그룹(e.x. Scanley 2.3, Singer 5.11.4)
- Dot은 십진수 지점 X: 숫자 혹은 dot 컴포넌트의 수 제한 X(일반적: 3 ~ 4개 사용)
- 표기 라벨을 태킹(Scanley 2.3.0(Alpha))
- 릴리즈 버전에 관계없이 표기 라벨을 부여하기도 함
- Alpha, Beta 이외에도 다양한 릴리즈 수준을 표현
    + Stable, Unstable, Development, RC(Release Candidate)
- 3-컴포넌트 릴리즈: (major).(minor).(micro)
    + major: 주요한 변화의 발생
    + minor: 마이너한 변화
    + micro: 사소한 변화
    + 4번째 숫자는 patch number로 주로 사용

## Semantic Versioning
- Backward-compatible
- 2.6.0 <-> 2.5.4: 클라이언트/서버 시스템인 경우
    + 2.6.0 클라이언트는 새로운 기능을 사용 가능
- 2.5.3 <-> 2.5.4: 클라이언트/서버 시스템인 경우
    + 기능의 차이는 존재하지 않지만 오류 등장 가능
- Micro 릴리즈는 bug fixes만을 다룸

# Release Branches
## Gitflow
- **master**: 기준이 되는 브랜치(제품 배포 브랜치)
- **develop**: 개발 브랜치(각자 작업한 기능 합침)
- **feature**: 단위 기능 개발 브랜치(기능 개발 완료 시 develop 브랜치로 합침)
- **release**: 배포를 위해 master 브랜치로 보내기 전 먼저 QA 실행 하기 위한 브랜치
- **hotfix**: master 브랜치로 배포했는데 버그가 생겼을 때 긴급 수정하는 브랜치

## 어떻게 프로젝트를 정규적인 릴리즈가 되도록 할 수 있는가?
- 불가능하다
    + 전체 개발트리가 릴리즈를 위해, Clean 및 Ready되는 시점은 어느 순간도 존재 X(새로 시작된 특징은 다양한 상태로 놓여져 있다.)
- Full-tree snapshots는 불가피하게 진행중인 개발작업을 방해할 수 있다.

## Release Branches
- 개별적인 버그와 특징에 대해 short-lived branches 생성
- 작업이 완료되는대로 가능한 main branch에 그들의 작업을 merge하길 기대함

## Mechanics of Release Branches
- Branch는 메인 라인 혹은 다른 Branch로부터 파생됨
- 메인 라인은 "1.0.x"릴리즈로 생각
    + 개발자의 변화는 처음으로 통합되고
    + Release 제약에 의해 자유롭고,
    + 선두적인 Branch이다.
- 안정적인 Release Branch에 대해, Tag 혹은 snapshot으로 지정

# Stabilizing a Release

## Stabilization
- Release Branch를 릴리즈가 가능한 상태로 만드는 과정
- **Featuer-Based Release**
    + 많은 변화 → 코드 불안정화, 더 많은 버그 출현
- **Time-Based Release**
    + 규칙적인 리듬에 새로운 릴리즈를 내놓는 것
    + 매 6개월마다, 버그와 특징에 관계없이 릴리즈
- 오픈소스 프로젝트에서 두 가지 전략
    + Release Owner에 의한 리더십
    + 변화에 대한 투표

## Dictatorship by Release Owner
- 최종 결정을 위한 충분한 권한 주기
- 릴리즈에 대한 일반적인 패턴
    + 변화에 대해 잘못된 것은 없다고 생각하지만, 그것에 대한 test할 시간이 충분하지 X So, 이번 release에 넣기에는 어렵다.
- 프로젝트 리더와 동일하지 않아도 괜찮

## Votin on Changes
- 어떠한 변화가 릴리즈에 투입될지에 대해 투표
    + **변화를 배제**하는 것이 안정화의 가장 중요한 기능
- Release Branch에 적용하는 투표 원칙
    + 적어도 3명의 개발자가 그것에 대해 투표해야 함
    + 그 중 한명은 거부권(Vetoes)를 가짐

## Release Manager
- 1 ~ 2명의 사람이 릴리즈 과정을 주도(변화에 대한 최종결정을 가진 Release Owner와는 차이가 있음)
- 주요 역할
    + 얼마나 많은 변화가 현재 고려중에 있는 지 추적
    + 얼마나 많은 변화가 승인되었는지
    + 얼마나 많은 것이 승인될 가능성이 있는지

# Packaging
- Free 소프트웨어 배포의 전통적인 형태 = 소스 코드(Compiled 혹은 Source form)
- 패키징 할 때, 주요 준수 사항
    + Format, Name and Layout, Compilation and Installation, Binary Packages

## Format
- 소스 코드는 디렉토리 트리를 유지하는 표준 포맷 내로 제공되어야 함
- **TAR format**: Unix 및 Unix 계열을 위한 포맷(compress, gzip, bzip, bzip2)
- **zip format**: Window 계열을 위한 포맷
- **Minified Version**: Javascript 프로젝트를 위한 소스파일도 함께 제공

## Minification
- Data compression 개념과는 차이가 있음

## Name and Layout
- 패키지 이름: 소프트웨어 이름 + 릴리즈 번호 + archive 타입에 적절한 suffix로 구성됨
    + Scanley-2.5.0.tar.gz
- 디렉토리 Top level에 존재하는 파일
    + README, Install, LICENSE/COPYING, Changes, News 파일이 존재

## Name and Layout
- 릴리즈는 정적 참조 포인트에서 파일들(Working copy 혹은 working files 단계가 아니어야 함)
- 여러 개의 소스 패키지에서 마이너한 차이점
    + CRLF(Carriage Return and Line Feed)와 LF간의 차이
    + CRLF: Windows 계열
    + LF: Unix 계열
- 첫 글자가 소문자/대문자 여부 관계 X
    + 압축해제시 생성되는 폴더 이름에는 주의할 것

## Compilation and Installation
- Unix 계열 시스템에서 C/C++ 기반 프로그램은 다음과 같이 사용자에게 요구
```bash
./configure # 빌드 과정을 위한 환경에 대한 자동 감지
make # 소프트웨어 빌드
sudo make install # 시스템에 빌드된 소프트웨어 설치
```
- 오늘날 Docker 기반의 컨테이너 기반 환경에 의해 손쉽게 프로그램 Deploy(배치) 가능

## Binary Packages
- Binary: 패키지의 사전 설정된 형태라는 뜻
- 공식 소스 릴리즈에 binary 패키지의 base를 확실히 할 것
- Packager은 수정사항을 개발자에게 가져와서 그들의 계획에 표현하기를 독려함